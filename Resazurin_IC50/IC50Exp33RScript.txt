# Resazurin Exp30 — per-sample dose–response with drc IC50s + CI ribbons
# Packages ----------------------------------------------------------------
suppressPackageStartupMessages({
  library(tidyverse)
  library(stringr)
  library(drc)
  library(glue)
  library(readr)
  library(scales)
})

# Paths -------------------------------------------------------------------
raw_path <- "Resazurin_IC50/Resazurin_Exp_33_Raw.txt"
cmp_path <- "Resazurin_IC50/Resazurin_Exp_33_Compound.txt"
out_dir  <- "Resazurin_IC50/resazurin_outputs/Exp33"
dir.create(out_dir, showWarnings = FALSE)
dir.create(file.path(out_dir, "plots"), showWarnings = FALSE)
dir.create(file.path(out_dir, "csv"),   showWarnings = FALSE)

# Helper: parse the RAW block-structured txt ------------------------------
parse_raw_blocks <- function(path) {
  lines <- readLines(path, warn = FALSE)
  hdr_ix <- grep(
    "^[^\\t]+_(A|B)_(Fluo|Abs|Abs_Background)\\t1\\t2\\t3\\t4\\t5\\t6\\t7\\t8\\t9\\t10\\t11\\t12",
    lines
  )
  stopifnot(length(hdr_ix) > 0)

  purrr::map_dfr(hdr_ix, function(i) {
    hdr <- lines[[i]]
    m <- str_match(hdr, "^([^\\t]+)_(A|B)_(Fluo|Abs|Abs_Background)")
    sample_id <- m[2]
    plate     <- m[3]
    meas      <- m[4]

    # Next 8 lines are the 8 concentration levels (1..8), each with 12 values
    block <- lines[(i+1):(i+8)]
    purrr::imap_dfr(block, function(ln, idx) {
      parts <- str_split(ln, "\\t", simplify = TRUE)
      lvl   <- suppressWarnings(as.integer(parts[1]))
      if (is.na(lvl)) lvl <- idx  # Exp33 rows don't have the 1..8 label; use row index
      vals  <- suppressWarnings(as.numeric(parts[2:13]))  # first 12 numbers are this meas
      tibble(sample_id, plate, meas, level = lvl,
            col = 1:12, value = vals)
    })
  })
}

raw_long <- parse_raw_blocks(raw_path)

# Helper: read the compound sheet & build mapping -------------------------
cmp <- read_tsv(cmp_path, show_col_types = FALSE)

# Map position (A1..A4, B1..B4) -> Compound name + Unit
key_map <- cmp %>%
  filter(ID %in% c("Compound", "Unit")) %>%
  pivot_longer(-ID, names_to = "pos", values_to = "val") %>%
  pivot_wider(names_from = ID, values_from = val) %>%
  rename(Unit = Unit)

# Concentrations per level (1..8) by position
dils <- cmp %>%
  filter(ID %in% as.character(1:8)) %>%
  mutate(level = as.integer(ID)) %>%
  dplyr::select(-ID) %>%
  pivot_longer(-level, names_to = "pos", values_to = "dose") %>%
  mutate(dose = as.numeric(dose)) %>%
  left_join(key_map, by = "pos") %>%
  mutate(plate = str_sub(pos, 1, 1),
         block = as.integer(str_sub(pos, 2, 2)))

# Tie raw columns to positions (triplicates per block) --------------------
dat <- raw_long %>%
  mutate(block = ((col - 1L) %/% 3L) + 1L,
         rep   = ((col - 1L) %% 3L) + 1L,
         pos   = paste0(plate, block)) %>%
  left_join(dils, by = c("pos", "level", "plate", "block"))

# We only need fluorescence for viability normalisation/fits --------------
fluo <- dat %>%
  filter(meas == "Fluo") %>%
  dplyr::select(sample_id, plate, pos, block, rep, level, dose, Unit, Compound, value)

# Compute top (vehicle, level=1) and bottoms (min signal) -----------------
top_map <- fluo %>%
  filter(level == 1) %>%
  group_by(sample_id, pos) %>%
  summarise(top = mean(value, na.rm = TRUE), .groups = "drop")

min_by_pos <- fluo %>%
  dplyr::filter(level >= 2, is.finite(value)) %>%   # keep only finite values
  dplyr::group_by(sample_id, pos) %>%
  dplyr::summarise(min_signal = min(value), .groups = "drop")

# Bottoms per curve = within-curve minimum (levels 2–8)
bottom_map <- min_by_pos %>%
  dplyr::transmute(sample_id, pos, bottom = min_signal)

# Merge tops/bottoms and compute normalised viability in [0,1] ------------
fluo_n <- fluo %>%
  left_join(top_map,    by = c("sample_id", "pos")) %>%
  left_join(bottom_map, by = c("sample_id", "pos")) %>%
  mutate(viab = (value - bottom) / pmax(top - bottom, .Machine$double.eps),
         viab = pmin(pmax(viab, 0), 1))

# Fitting + prediction helpers --------------------------------------------
# Delta-method 95% CI for LL.4 with fixed lower=0, upper=1
predict_ll4_ci <- function(fit, new_dose) {
  cf <- coef(fit)                   # parameters are c(b, c, d, e), but c and d fixed below
  vc <- vcov(fit)
  # When lower/upper are fixed at 0/1, vcov should be 2x2 for (b, e)
  b  <- unname(cf["b:(Intercept)"])
  e  <- unname(cf["e:(Intercept)"])
  # Safety for name variants
  if (is.na(b)) b <- unname(cf[grep("^b", names(cf))[1]])
  if (is.na(e)) e <- unname(cf[grep("^e", names(cf))[1]])

  x  <- new_dose
  t  <- b * (log(x) - log(e))
  et <- exp(t)
  den <- (1 + et)
  f   <- 1 / den

  K   <- et / (den^2)                      # common factor
  ddb <- -K * (log(x) - log(e))            # df/db
  dde <-  K * ( b / e )                    # df/de

  # Build gradient and variance
  G <- cbind(ddb, dde)                     # N x 2
  vars <- rowSums((G %*% vc) * G)          # diag(G V G^T)
  se   <- sqrt(pmax(vars, 0))
  tibble(dose = x, fit = f,
         lwr = pmax(f - 1.96 * se, 0),
         upr = pmin(f + 1.96 * se, 1))
}

fit_one_curve <- function(df, fix_bounds = TRUE) {
  dfit <- df %>% dplyr::filter(level >= 2, is.finite(dose), dose > 0)
  if (nrow(dfit) < 4L) return(NULL)

  fct <- if (fix_bounds) LL.4(fixed = c(NA, 0, 1, NA)) else LL.4()
  fit <- try(drm(viab ~ dose, data = dfit, fct = fct, robust = "mean"), silent = TRUE)
  if (inherits(fit, "try-error")) return(NULL)

  # IC50 (with SE & 95% CI)
  ic50 <- try(ED(fit, respLev = 0.5, type = "absolute", interval = "delta"), silent = TRUE)
  if (inherits(ic50, "try-error")) {
    ic50_df <- tibble(ED = NA_real_, SE = NA_real_, Lower = NA_real_, Upper = NA_real_)
  } else {
    ic50_df <- as_tibble(as.data.frame(ic50))
    # Standard ED() naming is (Estimate, Std. Error, Lower, Upper):
    names(ic50_df) <- c("ED", "SE", "Lower", "Upper")
  }

  # Prediction grid & CI ribbon
  rng  <- range(dfit$dose, na.rm = TRUE)
  grid <- tibble(dose = 10^seq(log10(rng[1]) - 0.05, log10(rng[2]) + 0.05, length.out = 200))
  pred <- predict_ll4_ci(fit, grid$dose)

  # Per-fit p-value for slope (dose–response trend)
  p_trend <- tryCatch({
    sm <- summary(fit)
    cm <- if (!is.null(sm$coefficients)) sm$coefficients else coef(sm)
    rn <- rownames(cm); colp <- grep("Pr", colnames(cm), value = TRUE)[1]
    idx <- grep("^b", rn)[1]
    as.numeric(cm[idx, colp])
  }, error = function(e) NA_real_)

  list(fit = fit,
       ic50 = ic50_df,
       pred = pred,
       points = dfit %>% dplyr::select(dose, viab, level, rep),
       p_trend = p_trend)
}

# Run fits for every sample × compound ------------------------------------
res_list <- fluo_n %>%
  dplyr::group_by(sample_id, Compound, Unit, pos) %>%
  dplyr::group_map(~{
    ans <- fit_one_curve(.x)
    tibble(
      sample_id = .y$sample_id, Compound = .y$Compound, Unit = .y$Unit, pos = .y$pos,
      fit_ok = !is.null(ans),
      p_trend = if (!is.null(ans)) ans$p_trend else NA_real_,
      ic50   = list(if (!is.null(ans)) ans$ic50 else tibble(ED=NA_real_, SE=NA_real_, Lower=NA_real_, Upper=NA_real_)),
      pred   = list(if (!is.null(ans)) ans$pred else tibble(dose=numeric(), fit=numeric(), lwr=numeric(), upr=numeric())),
      points = list(if (!is.null(ans)) ans$points else tibble(dose=numeric(), viab=numeric()))
    )
  }) %>% dplyr::bind_rows()

# IC50 table now includes SE and p_trend
ic50_tbl <- res_list %>%
  dplyr::transmute(sample_id, Compound, Unit, pos, fit_ok, p_trend, ic50) %>%
  tidyr::unnest(ic50) %>%
  dplyr::mutate(across(c(ED, SE, Lower, Upper), as.numeric)) %>%
  dplyr::arrange(sample_id, Compound)

readr::write_csv(ic50_tbl, file.path(out_dir, "csv", "IC50_results.csv"))

# --- Helpers for IC50 comparisons & pretty printing ---------------------------
ic50_compare <- function(e1, se1, e2, se2) {
  ok <- is.finite(e1) && is.finite(se1) && is.finite(e2) && is.finite(se2) && (e1 > 0) && (e2 > 0)
  if (!isTRUE(ok)) {
    return(tibble(ratio = NA_real_, ratio_lwr = NA_real_, ratio_upr = NA_real_, p_value = NA_real_))
  }
  l1 <- log(e1); l2 <- log(e2)
  s1l <- se1 / e1; s2l <- se2 / e2
  diff <- l1 - l2
  se   <- sqrt(s1l^2 + s2l^2)
  z    <- diff / se
  p    <- 2 * pnorm(abs(z), lower.tail = FALSE)
  tibble(ratio = exp(diff),
         ratio_lwr = exp(diff - 1.96*se),
         ratio_upr = exp(diff + 1.96*se),
         p_value = p)
}

pretty_p <- function(p) {
  if (!is.finite(p)) return("p = n/a")
  if (p < 1e-4) paste0("p = ", format(p, digits = 2, scientific = TRUE))
  paste0("p = ", signif(p, 3))
}

fmt_num <- function(x) {
  if (!is.finite(x)) return("n/a")
  if (x >= 0.01) formatC(x, format = "f", digits = 3)
  format(x, digits = 2, scientific = TRUE)
}

ic50_tbl2 <- ic50_tbl %>%
  dplyr::mutate(base = tolower(gsub("cse$", "", sample_id, ignore.case = TRUE)),
                is_cse = grepl("cse$", sample_id, ignore.case = TRUE))

# (A) sample vs samplecse for each compound (one row per base×compound)
cmp_across <- ic50_tbl2 %>%
  dplyr::group_by(base, Compound) %>%
  dplyr::filter(any(is_cse) & any(!is_cse)) %>%
  dplyr::summarise(
    sample_id      = first(sample_id[!is_cse]),
    samplecse_id   = first(sample_id[is_cse]),
    unit           = dplyr::coalesce(first(Unit[!is_cse]), first(Unit[is_cse])),
    e_sample       = first(ED[!is_cse]),
    se_sample      = first(SE[!is_cse]),
    e_samplecse    = first(ED[is_cse]),
    se_samplecse   = first(SE[is_cse]),
    .groups = "drop"
  ) %>%
  dplyr::rowwise() %>%
  dplyr::mutate(ic = ic50_compare(e_samplecse, se_samplecse, e_sample, se_sample)) %>%
  tidyr::unnest(ic) %>%
  dplyr::rename(IC50_sample = e_sample, SE_sample = se_sample,
                IC50_sampleCSE = e_samplecse, SE_sampleCSE = se_samplecse) %>%
  dplyr::arrange(base, Compound)

readr::write_csv(cmp_across, file.path(out_dir, "csv", "IC50_compare_sample_vs_sampleCSE.csv"))

# (B) Within-sample: generic <compound> vs <compound>_CSE
cmp_pairs <- ic50_tbl %>%
  dplyr::group_by(sample_id, comp_base = sub("_CSE$", "", Compound)) %>%
  dplyr::filter(any(grepl("_CSE$", Compound)) & any(!grepl("_CSE$", Compound))) %>%
  dplyr::summarise(
    unit      = dplyr::coalesce(first(Unit[!grepl("_CSE$", Compound)]), first(Unit[grepl("_CSE$", Compound)])),
    e_nonCSE  = ED[!grepl("_CSE$", Compound)][1],
    se_nonCSE = SE[!grepl("_CSE$", Compound)][1],
    e_CSE     = ED[ grepl("_CSE$", Compound)][1],
    se_CSE    = SE[ grepl("_CSE$", Compound)][1],
    .groups = "drop"
  ) %>%
  dplyr::rowwise() %>%
  dplyr::mutate(ic = ic50_compare(e_CSE, se_CSE, e_nonCSE, se_nonCSE)) %>%  # ratio = CSE / non-CSE
  tidyr::unnest(ic) %>%
  dplyr::rename(IC50_nonCSE = e_nonCSE, SE_nonCSE = se_nonCSE,
                IC50_CSE    = e_CSE,    SE_CSE    = se_CSE) %>%
  dplyr::arrange(sample_id, comp_base)

readr::write_csv(cmp_pairs, file.path(out_dir, "csv", "IC50_compare_generic_pairs.csv"))

# --- Combined plots -----------------------------------------------------------
# Folders for outputs
dir.create(file.path(out_dir, "plots_combined", "across_sample"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(out_dir, "plots_combined", "pairs_generic"), recursive = TRUE, showWarnings = FALSE)

# Helper to derive base id (pair sample with its "...cse")
base_id <- function(s) tolower(gsub("cse$", "", s, ignore.case = TRUE))

# Annotate res_list with pairing helpers
res_ann <- res_list %>%
  dplyr::mutate(
    base  = base_id(sample_id),
    is_cse = grepl("cse$", sample_id, ignore.case = TRUE)
  )

valid_bases <- res_ann %>%
  dplyr::distinct(base, is_cse) %>%
  dplyr::count(base, name = "n_groups") %>%
  dplyr::filter(n_groups == 2) %>%
  dplyr::pull(base)

# ---------- (1) Across sample vs samplecse: each compound, two curves ----------
# Only keep bases where both sample and samplecse exist
for (b in valid_bases) {
  sub <- res_ann %>% dplyr::filter(base == b, fit_ok)

  comps <- intersect(
    unique(sub %>% dplyr::filter(!is_cse) %>% dplyr::pull(Compound)),
    unique(sub %>% dplyr::filter( is_cse) %>% dplyr::pull(Compound))
  )

  for (cmp_name in comps) {
    d0 <- sub %>% dplyr::filter(Compound == cmp_name, !is_cse) %>% dplyr::slice(1)
    d1 <- sub %>% dplyr::filter(Compound == cmp_name,  is_cse) %>% dplyr::slice(1)
    if (nrow(d0) == 0 || nrow(d1) == 0) next

    pred <- dplyr::bind_rows(
      d0$pred[[1]]   %>% dplyr::mutate(group = paste0(d0$sample_id[[1]])),
      d1$pred[[1]]   %>% dplyr::mutate(group = paste0(d1$sample_id[[1]]))
    )
    pts  <- dplyr::bind_rows(
      d0$points[[1]] %>% dplyr::mutate(group = paste0(d0$sample_id[[1]])),
      d1$points[[1]] %>% dplyr::mutate(group = paste0(d1$sample_id[[1]]))
    )

    # IC50 vertical lines only
    ic0 <- d0$ic50[[1]][1, "ED", drop = TRUE]
    ic1 <- d1$ic50[[1]][1, "ED", drop = TRUE]
    vdat <- tibble::tibble(dose = c(ic0, ic1),
                           group = c(d0$sample_id[[1]], d1$sample_id[[1]]))

    unit_lbl  <- dplyr::coalesce(d0$Unit[[1]], d1$Unit[[1]])
    title_lbl <- glue::glue("{toupper(b)} — {cmp_name} (sample vs samplecse)")

    p <- ggplot2::ggplot() +
      ggplot2::geom_ribbon(data = pred, ggplot2::aes(dose, ymin = lwr, ymax = upr, fill = group), alpha = 0.18) +
      ggplot2::geom_line(  data = pred, ggplot2::aes(dose, fit, colour = group), linewidth = 0.9) +
      ggplot2::geom_point( data = pts,  ggplot2::aes(dose, viab, colour = group), size = 2, alpha = 0.85) +
      ggplot2::geom_vline(data = vdat, ggplot2::aes(xintercept = dose, colour = group),
                          linetype = 2, linewidth = 0.7, alpha = 0.9) +
      ggplot2::scale_x_log10(labels = scales::label_number(),
                              expand = ggplot2::expansion(mult = c(0.02, 0.05))) +
      ggplot2::coord_cartesian(ylim = c(0, 1)) +
      ggplot2::labs(title = title_lbl,
                    x = glue::glue("Concentration ({unit_lbl})"),
                    y = "Normalised viability", colour = NULL, fill = NULL) +
      ggplot2::theme_minimal(base_size = 12) +
      ggplot2::theme(plot.title = ggplot2::element_text(face = "bold"),
                     panel.grid.minor.x = ggplot2::element_blank())

    fn <- file.path(out_dir, "plots_combined", "across_sample",
                    glue::glue("combined_{b}_{gsub('[^A-Za-z0-9]+','_', cmp_name)}.png"))
    ggplot2::ggsave(fn, p, width = 6.8, height = 4.8, dpi = 300)
  }
}

# ---- Generic within-sample pairs: <compound> vs <compound>_CSE --------------
is_cse_compound <- function(x) grepl("_CSE$", x, ignore.case = TRUE)
base_compound   <- function(x) sub("_CSE$", "", x, ignore.case = TRUE)

# (ensure res_ann exists; you already defined it above)
pair_bases <- res_ann %>%
  dplyr::filter(fit_ok) %>%
  dplyr::mutate(comp_base = base_compound(Compound),
                comp_is_cse = is_cse_compound(Compound)) %>%
  dplyr::group_by(sample_id, comp_base) %>%
  dplyr::filter(any(comp_is_cse) & any(!comp_is_cse)) %>%
  dplyr::ungroup() %>%
  dplyr::distinct(sample_id, comp_base)

for (i in seq_len(nrow(pair_bases))) {
  sid <- pair_bases$sample_id[i]
  cb  <- pair_bases$comp_base[i]

  d_non <- res_ann %>%
    dplyr::filter(sample_id == sid, base_compound(Compound) == cb, !is_cse_compound(Compound)) %>%
    dplyr::slice(1)
  d_cse <- res_ann %>%
    dplyr::filter(sample_id == sid, base_compound(Compound) == cb,  is_cse_compound(Compound)) %>%
    dplyr::slice(1)
  if (!nrow(d_non) || !nrow(d_cse)) next

  pred <- dplyr::bind_rows(
    d_non$pred[[1]] %>% dplyr::mutate(group = d_non$Compound[[1]]),
    d_cse$pred[[1]] %>% dplyr::mutate(group = d_cse$Compound[[1]])
  )
  pts <- dplyr::bind_rows(
    d_non$points[[1]] %>% dplyr::mutate(group = d_non$Compound[[1]]),
    d_cse$points[[1]] %>% dplyr::mutate(group = d_cse$Compound[[1]])
  )
  vdat <- tibble::tibble(
    dose  = c(d_non$ic50[[1]][1, "ED", drop = TRUE],
              d_cse$ic50[[1]][1, "ED", drop = TRUE]),
    group = c(d_non$Compound[[1]], d_cse$Compound[[1]])
  )
  unit_lbl <- dplyr::coalesce(d_non$Unit[[1]], d_cse$Unit[[1]])

  p <- ggplot2::ggplot() +
    ggplot2::geom_ribbon(data = pred, ggplot2::aes(dose, ymin = lwr, ymax = upr, fill = group), alpha = 0.18) +
    ggplot2::geom_line(  data = pred, ggplot2::aes(dose, fit, colour = group), linewidth = 0.9) +
    ggplot2::geom_point( data = pts,  ggplot2::aes(dose, viab, colour = group), size = 2, alpha = 0.85) +
    ggplot2::geom_vline(data = vdat, ggplot2::aes(xintercept = dose, colour = group),
                        linetype = 2, linewidth = 0.7, alpha = 0.9) +
    ggplot2::scale_x_log10(labels = scales::label_number(),
                            expand = ggplot2::expansion(mult = c(0.02, 0.05))) +
    ggplot2::coord_cartesian(ylim = c(0, 1)) +
    ggplot2::labs(title = glue::glue("{sid} — {cb} vs {cb}_CSE"),
                  x = glue::glue("Concentration ({unit_lbl})"),
                  y = "Normalised viability", colour = NULL, fill = NULL) +
    ggplot2::theme_minimal(base_size = 12) +
    ggplot2::theme(plot.title = ggplot2::element_text(face = "bold"),
                   panel.grid.minor.x = ggplot2::element_blank())

  fn <- file.path(out_dir, "plots_combined", "pairs_generic",
                  glue::glue("combined_{gsub('[^A-Za-z0-9]+','_', sid)}_{gsub('[^A-Za-z0-9]+','_', cb)}_pair.png"))
  ggplot2::ggsave(fn, p, width = 6.8, height = 4.8, dpi = 300)
}

# --- Publication tables: bootstrap medians with 95% CIs -----------------------
set.seed(1234)

boot_ci <- function(x, B = 5000L) {
  x <- x[is.finite(x)]
  if (length(x) < 2L) return(c(NA_real_, NA_real_))
  bs <- replicate(B, stats::median(sample(x, replace = TRUE), na.rm = TRUE))
  stats::quantile(bs, c(0.025, 0.975), na.rm = TRUE, names = FALSE)
}

# (1) IC50 by compound (pooled across samples)
pub_ic50 <- ic50_tbl %>%
  dplyr::group_by(Compound, Unit) %>%
  dplyr::summarise(
    n = sum(is.finite(ED)),
    median = stats::median(ED, na.rm = TRUE),
    ci = list(boot_ci(ED)),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    CI_low = purrr::map_dbl(ci, 1),
    CI_high = purrr::map_dbl(ci, 2)
  ) %>%
  dplyr::select(-ci) %>%
  dplyr::arrange(Compound)

readr::write_csv(pub_ic50, file.path(out_dir, "csv", "pub_IC50_by_compound_bootstrap.csv"))

# (2) Across-sample ratios (sampleCSE / sample) per compound
cmp_across <- readr::read_csv(file.path(out_dir, "csv", "IC50_compare_sample_vs_sampleCSE.csv"), show_col_types = FALSE)

pub_ratio_across <- cmp_across %>%
  dplyr::group_by(Compound, unit) %>%
  dplyr::summarise(
    n = sum(is.finite(ratio)),
    median_ratio = stats::median(ratio, na.rm = TRUE),
    ci = list(boot_ci(ratio)),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    CI_low = purrr::map_dbl(ci, 1),
    CI_high = purrr::map_dbl(ci, 2)
  ) %>%
  dplyr::select(-ci) %>%
  dplyr::arrange(Compound)

readr::write_csv(pub_ratio_across, file.path(out_dir, "csv", "pub_Ratio_sampleCSE_over_sample_bootstrap.csv"))

# (3) Within-sample ratios for generic pairs (CSE / non-CSE), pooled across samples
pub_ratio_pairs <- cmp_pairs %>%
  dplyr::group_by(comp_base, unit) %>%
  dplyr::summarise(
    n = sum(is.finite(ratio)),
    median_ratio = stats::median(ratio, na.rm = TRUE),
    ci = list(boot_ci(ratio)),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    CI_low  = purrr::map_dbl(ci, 1),
    CI_high = purrr::map_dbl(ci, 2)
  ) %>%
  dplyr::select(-ci) %>%
  dplyr::arrange(comp_base)

readr::write_csv(pub_ratio_pairs, file.path(out_dir, "csv", "pub_Ratio_pairs_generic_bootstrap.csv"))

message("Done. IC50s: ", file.path(out_dir, "csv", "IC50_results.csv"),
        " — Plots in: ", file.path(out_dir, "plots"))